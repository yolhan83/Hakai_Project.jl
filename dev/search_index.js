var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Hakai_Project","category":"page"},{"location":"#Hakai_Project","page":"Home","title":"Hakai_Project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Hakai_Project.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Hakai_Project]","category":"page"},{"location":"#Hakai_Project.Hakai_Project","page":"Home","title":"Hakai_Project.Hakai_Project","text":"Package Hakai_Project v0.0.1\n\nThis package refactor code from https://github.com/yozoyugen/HAKAI-fem for user to use it.\n\n\n\n\n\n","category":"module"},{"location":"#Hakai_Project.applyBoundaryConditions!-NTuple{4, Any}","page":"Home","title":"Hakai_Project.applyBoundaryConditions!","text":"applyBoundaryConditions!(MODEL, disp_new, step, d_time)\n\nImplements the boundary conditions each time step, using amplitude interpolation.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.assignElementMaterial!-Tuple{Vector{Hakai_Project.PartType}, Vector{Hakai_Project.InstanceType}, Vector{Hakai_Project.MaterialType}}","page":"Home","title":"Hakai_Project.assignElementMaterial!","text":"assignElementMaterial!(PART, INSTANCE, MATERIAL) -> (element_material, element_instance)\n\nGiven PART, INSTANCE, and MATERIAL arrays, figure out the material assignments per element and also record which instance each element belongs to.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.buildGlobalModel!-Tuple{Vector{Hakai_Project.PartType}, Vector{Hakai_Project.InstanceType}}","page":"Home","title":"Hakai_Project.buildGlobalModel!","text":"buildGlobalModel!(PART, INSTANCE) -> (nNode, coordmat, nElement, elementmat)\n\nGiven the PART and INSTANCE arrays, iterates over each instance to:\n\napply translations/rotations\nassemble global coord and element arrays\n\nReturns the global node count, global coordinate matrix, global element count, and global element matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.buildMassDamping-Tuple{Any, Any}","page":"Home","title":"Hakai_Project.buildMassDamping","text":"buildMassDamping(MODEL, elementVolume; mass_scaling=1.0)\n\nConstructs the diagonal mass and damping arrays diagM, diagC based on element densities and volumes. Applies mass scaling.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.cal_BVbar_hexa-Tuple{Any, Any, Any}","page":"Home","title":"Hakai_Project.cal_BVbar_hexa","text":"cal_BVbar_hexa(Pusai_mat, e_position, BVbar)\n\nGiven:\n\nPusai_mat: a Vector of 8 SMatrix{3,8,Float64} (or MMatrix{3,8}), each storing the local shape  function derivatives at one Gauss point of a hexahedron.\ne_position: a 3×8 matrix of the current coordinates of this element’s nodes.\nBVbar: a 6×24 MMatrix (or Array) to which we add the volumetric parts for the B-bar approach.\n\nThis function:\n\nLoops over each of the 8 Gauss points.\nComputes the determinant of the Jacobian (detJi) from Pusai_mat[k] * e_position.\nAccumulates the (1/3)N(detJi) terms into BVbar[1:3, :].\nReturns the total element volume by summing the 8 detJi values.\n\nThe final BVbar is then used in a “Bbar” method (like Simo/Hughes anti-volumetric locking approach).\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.cal_Bfinal-NTuple{4, Any}","page":"Home","title":"Hakai_Project.cal_Bfinal","text":"cal_Bfinal(Bfinal, BVbar, Pusai1, e_position)\n\nComputes the final strain-displacement matrix Bfinal for a single Gauss point of an 8-node hexahedron using a \"B-bar\" type approach. Specifically:\n\nCompute the local 3×3 Jacobian from Pusai1 and e_position.\nInvert it and build the base B-matrix for the standard part.\nSubtract or add the volumetric correction from BVbar.\nReturn the determinant of the Jacobian (for weighting).\n\nArguments:   • Bfinal  : a 6×24 matrix (initially zero) where we'll store the final B at this Gauss point.   • BVbar   : a 6×24 matrix containing the volumetric part from cal_BVbar_hexa.   • Pusai1  : a 3×8 matrix of shape-function derivatives at this Gauss point (from Pusai_mat).   • e_position: a 3×8 matrix of the current coordinates of this element’s 8 nodes.\n\nReturns:   • detJi   : The determinant of the 3×3 Jacobian, used as the integration weight factor.\n\nNotes:   • If you strictly follow your original code logic, you might do:         Bfinal = B - BV + BVbar     or something similar. Here we embed that logic.     • The typical 6×24 B is formed from partial derivatives (dN/dx, etc.) mapped by the Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.cal_Pusai_hexa-Tuple{Any}","page":"Home","title":"Hakai_Project.cal_Pusai_hexa","text":"calPusaihexa(integ_num)\n\nGenerates the shape-function gradient matrices for an 8-integration-point hexahedral element. Returns an array of size integ_num where each entry is a 3×8 matrix (Pusai1), storing the derivatives of shape functions in local coordinates (gzai, eta, tueta).\n\ninteg_num is typically 8 for a standard hexahedron with 2×2×2 integration.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.cal_contact_force-Tuple{Any, Any, Any, Any, Matrix{Float64}, Vector{Float64}, Vector{Float64}, Float64, Float64, Float64, Vector{Int64}, Matrix{Int64}, Any, Any}","page":"Home","title":"Hakai_Project.cal_contact_force","text":"cal_contact_force(c_force3, CT, instance_pair, cp_index,\n                  position::Array{Float64,2}, velo::Array{Float64,1}, diag_M::Array{Float64,1},\n                  elementMinSize::Float64, elementMaxSize::Float64, d_max::Float64,\n                  element_flag::Array{Int,1}, elementmat::Array{Int,2}, bug_report, time_)\n\nComputes contact forces between a set of points (cnodesi) and triangular faces (c_triangles) from the ContactTriangle array CT. The core logic:\n\nFor each contact pair, gather the relevant nodes/triangles.\nBuild a small coarse grid (nodemapix, nodemapiy, nodemapiz, etc.) to skip far-apart node/triangle checks.\nFor any node that lies within the normal-projection distance d_lim from a triangle, compute normal penalty force and friction. Accumulate into c_force3.\nWe do both damping and friction calculations, so the contact model is basically a penalty approach.\n\nThe array c_force3 is 2D: size (fn × Threads.nthreads()) so each thread can accumulate forces without race conditions. The final combination is done after the function, by summation across the second dimension if needed.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.cal_node_stress_strain-Tuple{Int64, Matrix{Int64}, Int64, Hakai_Project.IntegDataType}","page":"Home","title":"Hakai_Project.cal_node_stress_strain","text":"cal_node_stress_strain(nNode::Int, elementmat::Array{Int,2}, integ_num::Int, integ_data::IntegDataType)\n\nAverages integration-point (Gauss-point) stress/strain values to each node. Returns a NodeDataType containing:\n\n• node_stress          (nNode×6)  – the averaged stress at each node   • node_strain          (nNode×6)  – the averaged strain at each node   • node_plastic_strain  (nNode×6)  – (currently unused, but included for completeness)   • node_eq_plastic_strain (nNode) – the averaged equivalent plastic strain at each node   • node_mises_stress    (nNode)   – Mises stress computed from node_stress   • node_triax_stress    (nNode)   – triaxial (mean stress / Mises) ratio\n\nNotes:\n\ninteg_data.integ_stress and integ_data.integ_strain are stored in column-major with shape (6 × nElement*integ_num). This function first aggregates them per element, then sums over nodes.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.cal_stress_hexa-Tuple{Any, Any, Any, Any, Any, Any, Any, Matrix{Int64}, Vector{Int64}, Int64, Any, Vector{Hakai_Project.MaterialType}, Vector{Int64}, Float64, Vector{Float64}}","page":"Home","title":"Hakai_Project.cal_stress_hexa","text":"cal_stress_hexa(Qe, integ_stress::Array{Float64,2}, integ_strain::Array{Float64,2},\n                integ_yield_stress::Array{Float64,1}, integ_eq_plastic_strain::Array{Float64,1},\n                position_::Array{Float64,2}, d_disp_::Array{Float64,1},\n                elementmat::Array{Int,2}, element_flag::Array{Int,1}, integ_num::Int,\n                Pusai_mat::Vector{SMatrix{3,8,Float64}},  # or your MMatrix type\n                MATERIAL::Array{MaterialType,1},\n                element_material::Array{Int,1},\n                elementMinSize::Float64,\n                elementVolume::Array{Float64,1})\n\nComputes the internal forces for each element (Qe) as well as updating integration-point stress/strain with an 8-integration-point hexahedral formulation. The parameters are:\n\n• Qe        : a 24×nElement array of element-level force vectors (24 = 3 dofs × 8 nodes).   • integ_stress : a 6×(nElementintegnum) array of stress at each Gauss point, updated in-place.   • `integstrain` : a 6×(nElementintegnum) array of strain at each Gauss point, updated in-place.   • `integyieldstress,integeqplasticstrain: 1D arrays for yield stress and eq. plastic strain, each has nElement*integ_num length.   •position: a 3×nNode array of current node coordinates.   •ddisp`   : a (3×nNode) vector storing this step's incremental displacement (dispnew - dispold).   • elementmat: an 8×nElement array listing node indices of each element.   • `elementflag: integer array (1 or 0) indicating which elements are active vs. deleted.   •integnum: number of integration points per element (8).   •Pusaimat: the shape-function derivative data for each integration point.   •MATERIAL: array of your customMaterialType, from which we get Dmat, G, plastic table, etc.   •element_material: an array giving the material ID for each element.   •elementMinSize: minimum element size (used in some checks, can be ignored if not used).   •elementVolume`    : array of size nElement for (maybe) updated volume if the code modifies it.\n\nWhat it does:\n\nLoops over each element (if element_flag[e] == 1).\nGathers that element’s incremental displacement, forms the B-matrix, and obtains the stress increment.\nIf the material is plastic, applies a radial return or linear hardening logic (the code does a simple “incremental” approach).\nUpdates integ_stress and integ_strain at each Gauss point.\nAccumulates the element internal force vector into the Qe array.\n\nReturns nothing, but modifies Qe, integ_stress, integ_strain, etc. in-place.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.computeElementVolumes-Tuple{Any, Any}","page":"Home","title":"Hakai_Project.computeElementVolumes","text":"computeElementVolumes(MODEL, Pusai_mat; integ_num=8)\n\nGiven the shape function matrix (Pusai_mat) and the MODEL's global coords, compute the volume for each element (summing over integration points). Returns an array of volumes, one per element.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.doFractureCheck!-NTuple{6, Any}","page":"Home","title":"Hakai_Project.doFractureCheck!","text":"doFractureCheck!(MODEL, element_flag, eq_plastic, triax, integ_stress, integ_strain)\n\nChecks which elements should be \"deleted\" (elementflag=0) based on the ductile data in MATERIAL. Sets integrstress/strain to zero in any deleted element's integration points. The logic matches your original code.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.drawGraph-Tuple{Any}","page":"Home","title":"Hakai_Project.drawGraph","text":"drawGraph(output)\n\nPlot the output (e.g. a time history) using Plots.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.findLineIndices-Tuple{Vector{String}, String}","page":"Home","title":"Hakai_Project.findLineIndices","text":"findLineIndices(lines::Vector{String}, pattern::String) -> Vector{Int}\n\nReturns all line indices in lines that contain the given pattern.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.get_element_face-Tuple{Any, Any}","page":"Home","title":"Hakai_Project.get_element_face","text":"get_element_face(MODEL, i)\n\nFor the i-th instance in MODEL, returns three arrays describing the faces of each hexahedral element:\n\nfaces       : A (nE*6)×4 matrix of node indices, where nE is the number of elements.                 Each group of 6 rows corresponds to the 6 faces of one element.\nfaces_eleid : A vector of length (nE*6) indicating which element each face row belongs to.\nsorted_faces: Same as faces but with each row sorted so that face matching can be performed                 (useful for detecting shared faces, external faces, etc.).\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.get_surface_triangle-Tuple{Any, Any, Any}","page":"Home","title":"Hakai_Project.get_surface_triangle","text":"get_surface_triangle(INSTANCE_i, array_element, contact_element)\n\nGiven a single InstanceType (INSTANCE_i), an array of local element indices (array_element), and a subset of those elements (contact_element), returns:\n\nc_triangles       : An array of triangle faces (two triangles per quadrilateral face).\nc_triangles_eleid : A matching array of element indices for each triangle row in c_triangles.\nc_nodes           : A sorted and unique list of all node indices used in c_triangles.\n\nThis is typically used in contact calculations to extract the exposed surface triangles for a subset of elements, so that point-vs-triangle collision or gap can be computed.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.initDisplacementVelocity-NTuple{5, Any}","page":"Home","title":"Hakai_Project.initDisplacementVelocity","text":"initDisplacementVelocity(MODEL, nNode, d_time, diag_M, mass_scaling)\n\nCreates and returns arrays for disp, dispnew, disppre, velo, and position. Also applies initial conditions from MODEL.IC if present.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.main-Tuple{Any}","page":"Home","title":"Hakai_Project.main","text":"main()\n\nRead the input file (from ARGS), run the simulation and produce output.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.my3SolveAb-NTuple{12, Float64}","page":"Home","title":"Hakai_Project.my3SolveAb","text":"my3SolveAb(A11::Float64, A21::Float64, A31::Float64,\n           A12::Float64, A22::Float64, A32::Float64,\n           A13::Float64, A23::Float64, A33::Float64,\n           bx::Float64, by::Float64, bz::Float64)\n\nSolves the 3×3 linear system A * x = b, where A is:     [ A11  A12  A13 ]     [ A21  A22  A23 ]     [ A31  A32  A33 ] and b = (bx, by, bz), returning (x1, x2, x3).\n\nIt effectively does a manual determinant-based inverse of A:\n\n```math (A^-1) = 1/det(A) * adj(A) then multiplies by b. \n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.my3crossNNz-NTuple{6, Float64}","page":"Home","title":"Hakai_Project.my3crossNNz","text":"my3crossNNz(a1::Float64, a2::Float64, a3::Float64, b1::Float64, b2::Float64, b3::Float64)\n\nReturns (nx, ny, nz) which is the normalized cross product of vectors a = (a1, a2, a3) and b = (b1, b2, b3). In other words, it does:\n\n```math n = (a × b) / ‖a × b‖ where ‖⋅‖ denotes the Euclidean norm. The result (nx, ny, nz) is the unit normal.\n\nExample usage: nx, ny, nz = my3crossNNz(1.0, 0.0, 0.0, 0.0, 1.0, 0.0)  # => (0, 0, 1)\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseAmplitudes-Tuple{Vector{String}}","page":"Home","title":"Hakai_Project.parseAmplitudes","text":"parseAmplitudes(lines) -> Vector{AmplitudeType}\n\nParses *Amplitude blocks.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseBC-Tuple{Vector{String}, Vector{Hakai_Project.AmplitudeType}, Vector{Hakai_Project.InstanceType}, Vector{Hakai_Project.PartType}, Vector{Hakai_Project.NsetType}}","page":"Home","title":"Hakai_Project.parseBC","text":"parseBC(lines, AMPLITUDE, INSTANCE, PART, NSET) -> Vector{BCType}\n\nParses *Boundary blocks, linking to amplitude if specified.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseContactFlag-Tuple{Vector{String}}","page":"Home","title":"Hakai_Project.parseContactFlag","text":"parseContactFlag(lines) -> Int\n\nChecks if *Contact or *Contact Inclusions (with self-contact) is present. Returns:   0 = no contact   1 = general contact   2 = self-contact\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseContactPairs-Tuple{Vector{String}, Vector{Hakai_Project.SurfaceType}}","page":"Home","title":"Hakai_Project.parseContactPairs","text":"parseContactPairs(lines, SURFACE) -> Vector{CPType}\n\nParses *Contact Pair blocks into CPType.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseGlobalElsets-Tuple{Vector{String}, Vector{Hakai_Project.InstanceType}}","page":"Home","title":"Hakai_Project.parseGlobalElsets","text":"parseGlobalElsets(lines, INSTANCE) -> Vector{ELsetType}\n\nParses any *Elset with \"instance=\" at the global level.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseGlobalNsets-Tuple{Vector{String}, Vector{Hakai_Project.InstanceType}}","page":"Home","title":"Hakai_Project.parseGlobalNsets","text":"parseGlobalNsets(lines, INSTANCE) -> Vector{NsetType}\n\nParses any *Nset with \"instance=\" at the global level.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseIC-Tuple{Vector{String}, Vector{Hakai_Project.InstanceType}, Vector{Hakai_Project.PartType}, Vector{Hakai_Project.NsetType}}","page":"Home","title":"Hakai_Project.parseIC","text":"parseIC(lines, INSTANCE, PART, NSET) -> Vector{ICType}\n\nParses *Initial Conditions blocks.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseInstances-Tuple{Vector{String}, Vector{Hakai_Project.PartType}}","page":"Home","title":"Hakai_Project.parseInstances","text":"parseInstances(lines, PART) -> Vector{InstanceType}\n\nFinds all *Instance blocks and populates an array of InstanceType.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseMassScaling-Tuple{Vector{String}}","page":"Home","title":"Hakai_Project.parseMassScaling","text":"parseMassScaling(lines) -> Float64\n\nParses *Fixed Mass Scaling to obtain mass scaling factor.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseMaterials-Tuple{Vector{String}}","page":"Home","title":"Hakai_Project.parseMaterials","text":"parseMaterials(lines) -> Vector{MaterialType}\n\nParses *Material blocks.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseParts-Tuple{Vector{String}}","page":"Home","title":"Hakai_Project.parseParts","text":"parseParts(lines::Vector{String}) -> Vector{PartType}\n\nParses all *Part sections (with nodes/elements) into an array of PartType.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseStep-Tuple{Vector{String}}","page":"Home","title":"Hakai_Project.parseStep","text":"parseStep(lines) -> (d_time, end_time)\n\nParses *Dynamic, Explicit parameters.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.parseSurfaces-Tuple{Vector{String}, Vector{Hakai_Project.ELsetType}}","page":"Home","title":"Hakai_Project.parseSurfaces","text":"parseSurfaces(lines, ELSET) -> Vector{SurfaceType}\n\nParses *Surface blocks and populates SurfaceType.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.prepareMaterialProperties!-Tuple{Any}","page":"Home","title":"Hakai_Project.prepareMaterialProperties!","text":"prepareMaterialProperties!(MODEL)\n\nLoops over MODEL.MATERIAL to compute and store properties like G, Dmat, and detect if there's any fracture. Returns a flag indicating whether fracture is enabled in the model.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.readFile-Tuple{String}","page":"Home","title":"Hakai_Project.readFile","text":"readFile(fname::String) -> Vector{String}\n\nReads the entire input file into a vector of lines.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.readInpFile-Tuple{String}","page":"Home","title":"Hakai_Project.readInpFile","text":"readInpFile(fname::String) -> ModelType\n\nTop-level function that reads all lines of the .inp file, then parses out all relevant sections into a ModelType.\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.runMainTimeLoop!-NTuple{11, Any}","page":"Home","title":"Hakai_Project.runMainTimeLoop!","text":"runMainTimeLoop!(MODEL, diag_M, diag_C, disp, disp_new, disp_pre, velo, position,\n                 contactData, elementVolume, Pusai_mat)\n\nImplements the central time-stepping loop:\n\nupdates external forces\ncomputes contact forces\nenforces boundary conditions\nupdates stress/strain\nfracture removal\nwrites output periodically\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.setupContact!-Tuple{Any}","page":"Home","title":"Hakai_Project.setupContact!","text":"setupContact!(MODEL)\n\nHandles logic to build up contact pairs, surfaces, etc. Returns a struct or NamedTuple with contact data (CT, instancepair, cpindex, etc.).\n\n\n\n\n\n","category":"method"},{"location":"#Hakai_Project.write_vtk-Tuple{Int64, AbstractMatrix{Float64}, AbstractMatrix{Int64}, AbstractVector{Int64}, AbstractVector{Float64}, AbstractVector{Float64}, Hakai_Project.NodeDataType}","page":"Home","title":"Hakai_Project.write_vtk","text":"write_vtk(index::Int, coordmat::AbstractMatrix{T}, elementmat::AbstractMatrix{Int},\n          element_flag::AbstractVector{Int}, disp::AbstractVector{T}, velo::AbstractVector{T},\n          node_data::NodeDataType)\n\nWrites a .vtk file (in unstructured-grid format) for the mesh and nodal data at the given index. Stores the file in temp/file###.vtk.\n\nArguments:   • coordmat     : a 3×nNode matrix of the original node coordinates (column-major).   • elementmat   : an 8×nElement matrix of node indices for each hexahedral element.   • element_flag : an nElement vector of 1/0 flags indicating whether each element is active or deleted.   • disp         : a 3nNode vector of nodal displacements, stored in [x1,y1,z1, x2,y2,z2, …].   • velo         : a 3nNode vector of nodal velocities, same layout as disp.   • node_data    : a NodeDataType struct, containing node-level stresses, strains, etc.\n\nOutput:   • Creates a file named \"temp/file###.vtk\" where ### is the zero-padded index.\n\nNotes:   • The VTK file is ASCII, \"DATASET UNSTRUCTUREDGRID\".   • Only hex8 cell types are handled (CELLTYPES 12).\n\n\n\n\n\n","category":"method"}]
}
